!function(){var e=function(e){function t(i){if(n[i])return n[i].exports;var r=n[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,t),r.l=!0,r.exports}var n={};return t.m=e,t.c=n,t.i=function(e){return e},t.d=function(e,n,i){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:i})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=6)}([function(e,t){var n="ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԧԱ-Ֆՙա-ևא-תװ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࢠࢢ-ࢬऄ-हऽॐक़-ॡॱ-ॷॹ-ॿঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-ళవ-హఽౘౙౠౡಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൠൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏼᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛰᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡷᢀ-ᢨᢪᢰ-ᣵᤀ-ᤜᥐ-ᥭᥰ-ᥴᦀ-ᦫᧁ-ᧇᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᳩ-ᳬᳮ-ᳱᳵᳶᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞⸯ々-〇〡-〩〱-〵〸-〼ぁ-ゖゝ-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿌ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚗꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞎꞐ-ꞓꞠ-Ɦꟸ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꪀ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꯀ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ",i=new RegExp("["+n+"]"),r=new RegExp("["+n+"̀-ͯ҃-֑҇-ׇֽֿׁׂׅׄؐ-ؚؠ-ىٲ-ۓۧ-ۨۻ-ۼܰ-݊ࠀ-ࠔࠛ-ࠣࠥ-ࠧࠩ-࠭ࡀ-ࡗࣤ-ࣾऀ-ःऺ-़ा-ॏ॑-ॗॢ-ॣ०-९ঁ-ঃ়া-ৄেৈৗয়-ৠਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢ-ૣ૦-૯ଁ-ଃ଼ା-ୄେୈୋ-୍ୖୗୟ-ୠ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఁ-ఃె-ైొ-్ౕౖౢ-ౣ౦-౯ಂಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢ-ೣ೦-೯ംഃെ-ൈൗൢ-ൣ൦-൯ංඃ්ා-ුූෘ-ෟෲෳิ-ฺเ-ๅ๐-๙ິ-ູ່-ໍ໐-໙༘༙༠-༩༹༵༷ཁ-ཇཱ-྄྆-྇ྍ-ྗྙ-ྼ࿆က-ဩ၀-၉ၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟ᜎ-ᜐᜠ-ᜰᝀ-ᝐᝲᝳក-ឲ៝០-៩᠋-᠍᠐-᠙ᤠ-ᤫᤰ-᤻ᥑ-ᥭᦰ-ᧀᧈ-ᧉ᧐-᧙ᨀ-ᨕᨠ-ᩓ᩠-᩿᩼-᪉᪐-᪙ᭆ-ᭋ᭐-᭙᭫-᭳᮰-᮹᯦-᯳ᰀ-ᰢ᱀-᱉ᱛ-ᱽ᳐-᳒ᴀ-ᶾḁ-ἕ‌‍‿⁀⁔⃐-⃥⃜⃡-⃰ⶁ-ⶖⷠ-ⷿ〡-〨゙゚Ꙁ-ꙭꙴ-꙽ꚟ꛰-꛱ꟸ-ꠀ꠆ꠋꠣ-ꠧꢀ-ꢁꢴ-꣄꣐-꣙ꣳ-ꣷ꤀-꤉ꤦ-꤭ꤰ-ꥅꦀ-ꦃ꦳-꧀ꨀ-ꨧꩀ-ꩁꩌ-ꩍ꩐-꩙ꩻꫠ-ꫩꫲ-ꫳꯀ-ꯡ꯬꯭꯰-꯹ﬠ-ﬨ︀-️︠-︦︳︴﹍-﹏０-９＿]");t.newline=/[\n\r\u2028\u2029]/,t.lineBreak=new RegExp("\r\n|"+t.newline.source),t.allLineBreaks=new RegExp(t.lineBreak.source,"g"),t.isIdentifierStart=function(e){return e<65?36===e||64===e:e<91||(e<97?95===e:e<123||e>=170&&i.test(String.fromCharCode(e)))},t.isIdentifierChar=function(e){return e<48?36===e:e<58||!(e<65)&&(e<91||(e<97?95===e:e<123||e>=170&&r.test(String.fromCharCode(e))))}},function(e,t,n){function i(e,t){if(!t.multiline_frame&&t.mode!==h.ForInitializer&&t.mode!==h.Conditional){var n=t.start_line_index;e.remove_indent(n)}}function r(e,t){for(var n=0;n<t.length;n+=1)if(t[n]===e)return!0;return!1}function _(e){return e.replace(/^\s+|\s+$/g,"")}function a(e){return e.replace(/^\s+/g,"")}function o(e){if(e=e||u.before_newline,!r(e,f))throw new Error("Invalid Option Value: The option 'operator_position' must be one of the following values\n"+f+"\nYou passed in: '"+e+"'");return e}var s=n(3).mergeOpts,l=n(0),c=n(4).Output,p=n(7).Tokenizer,f=["before-newline","after-newline","preserve-newline"],u=function(e){for(var t={},n=0;n<e.length;n++)t[e[n].replace(/-/g,"_")]=e[n];return t}(f),d=[u.before_newline,u.preserve_newline],h={BlockStatement:"BlockStatement",Statement:"Statement",ObjectLiteral:"ObjectLiteral",ArrayLiteral:"ArrayLiteral",ForInitializer:"ForInitializer",Conditional:"Conditional",Expression:"Expression"};e.exports.Beautifier=function(e,t){"use strict";function n(e,t){var n=0;return e&&(n=e.indentation_level,!L.just_added_newline()&&e.line_indent_level>n&&(n=e.line_indent_level)),{mode:t,parent:e,last_text:e?e.last_text:"",last_word:e?e.last_word:"",declaration_statement:!1,declaration_assignment:!1,multiline_frame:!1,inline_frame:!1,if_block:!1,else_block:!1,do_block:!1,do_while:!1,import_block:!1,in_case_statement:!1,in_case:!1,case_body:!1,indentation_level:n,line_indent_level:e?e.line_indent_level:n,start_line_index:L.get_line_number(),ternary_depth:0}}function f(e,t){for(var n=e.newlines,i=Q.keep_array_indentation&&k(W.mode),r=B,_=0;_<e.comments_before.length;_++)f(B=e.comments_before[_],t),U[B.type](t);if(B=r,i)for(var a=0;a<n;a+=1)x(a>0,t);else if(Q.max_preserve_newlines&&n>Q.max_preserve_newlines&&(n=Q.max_preserve_newlines),Q.preserve_newlines&&e.newlines>1){x(!1,t);for(var o=1;o<n;o+=1)x(!0,t)}}function T(e){for(var t=[],n=(e=e.replace(l.allLineBreaks,"\n")).indexOf("\n");-1!==n;)t.push(e.substring(0,n)),n=(e=e.substring(n+1)).indexOf("\n");return e.length&&t.push(e),t}function E(e){if(e=void 0!==e&&e,!L.just_added_newline()){var t=Q.preserve_newlines&&B.wanted_newline||e;if(r(W.last_text,P.positionable_operators)||r(B.text,P.positionable_operators)){var n=r(W.last_text,P.positionable_operators)&&r(Q.operator_position,d)||r(B.text,P.positionable_operators);t=t&&n}if(t)x(!1,!0);else if(Q.wrap_line_length){if("TK_RESERVED"===M&&r(W.last_text,q))return;L.current_line.get_character_count()+B.text.length+(L.space_before_token?1:0)>=Q.wrap_line_length&&x(!1,!0)}}}function x(e,t){if(!t&&";"!==W.last_text&&","!==W.last_text&&"="!==W.last_text&&"TK_OPERATOR"!==M)for(var n=C(1);!(W.mode!==h.Statement||W.if_block&&n&&"TK_RESERVED"===n.type&&"else"===n.text||W.do_block);)O();L.add_new_line(e)&&(W.multiline_frame=!0)}function R(){L.just_added_newline()&&(Q.keep_array_indentation&&k(W.mode)&&B.wanted_newline?(L.current_line.push(B.whitespace_before),L.space_before_token=!1):L.set_indent(W.indentation_level)&&(W.line_indent_level=W.indentation_level))}function K(e){if(L.raw)L.add_raw_token(B);else{if(Q.comma_first&&"TK_COMMA"===M&&L.just_added_newline()&&","===L.previous_line.last()){var t=L.previous_line.pop();L.previous_line.is_empty()&&(L.previous_line.push(t),L.trim(!0),L.current_line.pop(),L.trim()),R(),L.add_token(","),L.space_before_token=!0}e=e||B.text,R(),L.add_token(e)}}function m(){W.indentation_level+=1}function b(){W.indentation_level>0&&(!W.parent||W.indentation_level>W.parent.indentation_level)&&(W.indentation_level-=1)}function v(e){W?(z.push(W),X=W):X=n(null,e),W=n(X,e)}function k(e){return e===h.ArrayLiteral}function w(e){return r(e,[h.Expression,h.ForInitializer,h.Conditional])}function O(){z.length>0&&(X=W,W=z.pop(),X.mode!==h.Statement||Q.unindent_chained_methods||i(L,X))}function S(){return W.parent.mode===h.ObjectLiteral&&W.mode===h.Statement&&(":"===W.last_text&&0===W.ternary_depth||"TK_RESERVED"===M&&r(W.last_text,["get","set"]))}function y(){return!!("TK_RESERVED"===M&&r(W.last_text,["var","let","const"])&&"TK_WORD"===B.type||"TK_RESERVED"===M&&"do"===W.last_text||"TK_RESERVED"===M&&r(W.last_text,q)&&!B.wanted_newline||"TK_RESERVED"===M&&"else"===W.last_text&&("TK_RESERVED"!==B.type||"if"!==B.text||B.comments_before.length)||"TK_END_EXPR"===M&&(X.mode===h.ForInitializer||X.mode===h.Conditional)||"TK_WORD"===M&&W.mode===h.BlockStatement&&!W.in_case&&"--"!==B.text&&"++"!==B.text&&"function"!==I&&"TK_WORD"!==B.type&&"TK_RESERVED"!==B.type||W.mode===h.ObjectLiteral&&(":"===W.last_text&&0===W.ternary_depth||"TK_RESERVED"===M&&r(W.last_text,["get","set"])))&&(v(h.Statement),Q.unindent_chained_methods||m(),f(B,!0),S()||E("TK_RESERVED"===B.type&&r(B.text,["do","for","if","while"])),!0)}function g(e,t){for(var n=0;n<e.length;n++)if(_(e[n]).charAt(0)!==t)return!1;return!0}function D(e,t){for(var n,i=0,r=e.length;i<r;i++)if((n=e[i])&&0!==n.indexOf(t))return!1;return!0}function A(e){return r(e,["case","return","do","if","throw","else"])}function C(e){var t=V+(e||0);return t<0||t>=$.length?null:$[t]}function N(){if("TK_RESERVED"===B.type&&(r(B.text,["set","get"])&&W.mode!==h.ObjectLiteral?B.type="TK_WORD":r(B.text,["as","from"])&&!W.import_block?B.type="TK_WORD":W.mode===h.ObjectLiteral&&":"===C(1).text&&(B.type="TK_WORD")),y()?"TK_RESERVED"===M&&r(W.last_text,["var","let","const"])&&"TK_WORD"===B.type&&(W.declaration_statement=!0):!B.wanted_newline||w(W.mode)||"TK_OPERATOR"===M&&"--"!==W.last_text&&"++"!==W.last_text||"TK_EQUALS"===M||!Q.preserve_newlines&&"TK_RESERVED"===M&&r(W.last_text,["var","let","const","set","get"])?f(B):(f(B),x()),W.do_block&&!W.do_while){if("TK_RESERVED"===B.type&&"while"===B.text)return L.space_before_token=!0,K(),L.space_before_token=!0,void(W.do_while=!0);x(),W.do_block=!1}if(W.if_block)if(W.else_block||"TK_RESERVED"!==B.type||"else"!==B.text){for(;W.mode===h.Statement;)O();W.if_block=!1,W.else_block=!1}else W.else_block=!0;return"TK_RESERVED"===B.type&&("case"===B.text||"default"===B.text&&W.in_case_statement)?(x(),(W.case_body||Q.jslint_happy)&&(b(),W.case_body=!1),K(),W.in_case=!0,void(W.in_case_statement=!0)):("TK_COMMA"!==M&&"TK_START_EXPR"!==M&&"TK_EQUALS"!==M&&"TK_OPERATOR"!==M||S()||E(),"TK_RESERVED"===B.type&&"function"===B.text?((r(W.last_text,["}",";"])||L.just_added_newline()&&!r(W.last_text,["(","[","{",":","=",","])&&"TK_OPERATOR"!==M)&&(L.just_added_blankline()||B.comments_before.length||(x(),x(!0))),"TK_RESERVED"===M||"TK_WORD"===M?"TK_RESERVED"===M&&(r(W.last_text,["get","set","new","export","async"])||r(W.last_text,q))?L.space_before_token=!0:"TK_RESERVED"===M&&"default"===W.last_text&&"export"===I?L.space_before_token=!0:x():"TK_OPERATOR"===M||"="===W.last_text?L.space_before_token=!0:(W.multiline_frame||!w(W.mode)&&!k(W.mode))&&x(),K(),void(W.last_word=B.text)):(F="NONE","TK_END_BLOCK"===M?X.inline_frame?F="SPACE":"TK_RESERVED"===B.type&&r(B.text,["else","catch","finally","from"])?"expand"===Q.brace_style||"end-expand"===Q.brace_style||"none"===Q.brace_style&&B.wanted_newline?F="NEWLINE":(F="SPACE",L.space_before_token=!0):F="NEWLINE":"TK_SEMICOLON"===M&&W.mode===h.BlockStatement?F="NEWLINE":"TK_SEMICOLON"===M&&w(W.mode)?F="SPACE":"TK_STRING"===M?F="NEWLINE":"TK_RESERVED"===M||"TK_WORD"===M||"*"===W.last_text&&(r(I,["function","yield"])||W.mode===h.ObjectLiteral&&r(I,["{",","]))?F="SPACE":"TK_START_BLOCK"===M?F=W.inline_frame?"SPACE":"NEWLINE":"TK_END_EXPR"===M&&(L.space_before_token=!0,F="NEWLINE"),"TK_RESERVED"===B.type&&r(B.text,P.line_starters)&&")"!==W.last_text&&(F=W.inline_frame||"else"===W.last_text||"export"===W.last_text?"SPACE":"NEWLINE"),"TK_RESERVED"===B.type&&r(B.text,["else","catch","finally"])?("TK_END_BLOCK"!==M||X.mode!==h.BlockStatement||"expand"===Q.brace_style||"end-expand"===Q.brace_style||"none"===Q.brace_style&&B.wanted_newline)&&!W.inline_frame?x():(L.trim(!0),"}"!==L.current_line.last()&&x(),L.space_before_token=!0):"NEWLINE"===F?"TK_RESERVED"===M&&A(W.last_text)?L.space_before_token=!0:"TK_END_EXPR"!==M?"TK_START_EXPR"===M&&"TK_RESERVED"===B.type&&r(B.text,["var","let","const"])||":"===W.last_text||("TK_RESERVED"===B.type&&"if"===B.text&&"else"===W.last_text?L.space_before_token=!0:x()):"TK_RESERVED"===B.type&&r(B.text,P.line_starters)&&")"!==W.last_text&&x():W.multiline_frame&&k(W.mode)&&","===W.last_text&&"}"===I?x():"SPACE"===F&&(L.space_before_token=!0),K(),W.last_word=B.text,void("TK_RESERVED"===B.type&&("do"===B.text?W.do_block=!0:"if"===B.text?W.if_block=!0:"import"===B.text?W.import_block=!0:W.import_block&&"TK_RESERVED"===B.type&&"from"===B.text&&(W.import_block=!1)))))}var L,V,P,B,M,I,j,W,X,z,F,U,Q,$=[],Z="";U={TK_START_EXPR:function(){y()||f(B);var e=h.Expression;if("["===B.text){if("TK_WORD"===M||")"===W.last_text)return"TK_RESERVED"===M&&r(W.last_text,P.line_starters)&&(L.space_before_token=!0),v(e),K(),m(),void(Q.space_in_paren&&(L.space_before_token=!0));e=h.ArrayLiteral,k(W.mode)&&("["!==W.last_text&&(","!==W.last_text||"]"!==I&&"}"!==I)||Q.keep_array_indentation||x())}else"TK_RESERVED"===M&&"for"===W.last_text?e=h.ForInitializer:"TK_RESERVED"===M&&r(W.last_text,["if","while"])&&(e=h.Conditional);";"===W.last_text||"TK_START_BLOCK"===M?x():"TK_END_EXPR"===M||"TK_START_EXPR"===M||"TK_END_BLOCK"===M||"."===W.last_text?E(B.wanted_newline):"TK_RESERVED"===M&&"("===B.text||"TK_WORD"===M||"TK_OPERATOR"===M?"TK_RESERVED"===M&&("function"===W.last_word||"typeof"===W.last_word)||"*"===W.last_text&&(r(I,["function","yield"])||W.mode===h.ObjectLiteral&&r(I,["{",","]))?Q.space_after_anon_function&&(L.space_before_token=!0):"TK_RESERVED"!==M||!r(W.last_text,P.line_starters)&&"catch"!==W.last_text||Q.space_before_conditional&&(L.space_before_token=!0):L.space_before_token=!0,"("===B.text&&"TK_RESERVED"===M&&r(W.last_word,["await","async"])&&(L.space_before_token=!0),"("===B.text&&("TK_EQUALS"!==M&&"TK_OPERATOR"!==M||S()||E()),"("===B.text&&"TK_WORD"!==M&&"TK_RESERVED"!==M&&E(),v(e),K(),Q.space_in_paren&&(L.space_before_token=!0),m()},TK_END_EXPR:function(){for(;W.mode===h.Statement;)O();f(B),W.multiline_frame&&E("]"===B.text&&k(W.mode)&&!Q.keep_array_indentation),Q.space_in_paren&&("TK_START_EXPR"!==M||Q.space_in_empty_paren?L.space_before_token=!0:(L.trim(),L.space_before_token=!1)),"]"===B.text&&Q.keep_array_indentation?(K(),O()):(O(),K()),i(L,X),W.do_while&&X.mode===h.Conditional&&(X.mode=h.Expression,W.do_block=!1,W.do_while=!1)},TK_START_BLOCK:function(){f(B);var e=C(1),t=C(2);v(t&&(r(t.text,[":",","])&&r(e.type,["TK_STRING","TK_WORD","TK_RESERVED"])||r(e.text,["get","set","..."])&&r(t.type,["TK_WORD","TK_RESERVED"]))?r(I,["class","interface"])?h.BlockStatement:h.ObjectLiteral:"TK_OPERATOR"===M&&"=>"===W.last_text?h.BlockStatement:r(M,["TK_EQUALS","TK_START_EXPR","TK_COMMA","TK_OPERATOR"])||"TK_RESERVED"===M&&r(W.last_text,["return","throw","import","default"])?h.ObjectLiteral:h.BlockStatement);var n=!e.comments_before.length&&"}"===e.text&&"function"===W.last_word&&"TK_END_EXPR"===M;if(Q.brace_preserve_inline){var i=0,_=null;W.inline_frame=!0;do{if(i+=1,(_=C(i)).wanted_newline){W.inline_frame=!1;break}}while("TK_EOF"!==_.type&&("TK_END_BLOCK"!==_.type||_.opened!==B))}("expand"===Q.brace_style||"none"===Q.brace_style&&B.wanted_newline)&&!W.inline_frame?"TK_OPERATOR"!==M&&(n||"TK_EQUALS"===M||"TK_RESERVED"===M&&A(W.last_text)&&"else"!==W.last_text)?L.space_before_token=!0:x(!1,!0):(!k(X.mode)||"TK_START_EXPR"!==M&&"TK_COMMA"!==M||(("TK_COMMA"===M||Q.space_in_paren)&&(L.space_before_token=!0),("TK_COMMA"===M||"TK_START_EXPR"===M&&W.inline_frame)&&(E(),X.multiline_frame=X.multiline_frame||W.multiline_frame,W.multiline_frame=!1)),"TK_OPERATOR"!==M&&"TK_START_EXPR"!==M&&("TK_START_BLOCK"!==M||W.inline_frame?L.space_before_token=!0:x())),K(),m()},TK_END_BLOCK:function(){for(f(B);W.mode===h.Statement;)O();var e="TK_START_BLOCK"===M;W.inline_frame&&!e?L.space_before_token=!0:"expand"===Q.brace_style?e||x():e||(k(W.mode)&&Q.keep_array_indentation?(Q.keep_array_indentation=!1,x(),Q.keep_array_indentation=!0):x()),O(),K()},TK_WORD:N,TK_RESERVED:N,TK_SEMICOLON:function(){y()?L.space_before_token=!1:f(B);for(var e=C(1);!(W.mode!==h.Statement||W.if_block&&e&&"TK_RESERVED"===e.type&&"else"===e.text||W.do_block);)O();W.import_block&&(W.import_block=!1),K()},TK_STRING:function(){y()?L.space_before_token=!0:(f(B),"TK_RESERVED"===M||"TK_WORD"===M||W.inline_frame?L.space_before_token=!0:"TK_COMMA"===M||"TK_START_EXPR"===M||"TK_EQUALS"===M||"TK_OPERATOR"===M?S()||E():x()),K()},TK_EQUALS:function(){y()||f(B),W.declaration_statement&&(W.declaration_assignment=!0),L.space_before_token=!0,K(),L.space_before_token=!0},TK_OPERATOR:function(){var e="*"===B.text&&("TK_RESERVED"===M&&r(W.last_text,["function","yield"])||r(M,["TK_START_BLOCK","TK_COMMA","TK_END_BLOCK","TK_SEMICOLON"])),t=r(B.text,["-","+"])&&(r(M,["TK_START_BLOCK","TK_START_EXPR","TK_EQUALS","TK_OPERATOR"])||r(W.last_text,P.line_starters)||","===W.last_text);if(y()||f(B,!e),"TK_RESERVED"===M&&A(W.last_text))return L.space_before_token=!0,void K();if("*"!==B.text||"TK_DOT"!==M)if("::"!==B.text){if("TK_OPERATOR"===M&&r(Q.operator_position,d)&&E(),":"===B.text&&W.in_case)return W.case_body=!0,m(),K(),x(),void(W.in_case=!1);var n=!0,i=!0,_=!1;if(":"===B.text?0===W.ternary_depth?n=!1:(W.ternary_depth-=1,_=!0):"?"===B.text&&(W.ternary_depth+=1),!t&&!e&&Q.preserve_newlines&&r(B.text,P.positionable_operators)){var a=":"===B.text,o=a&&_,s=a&&!_;switch(Q.operator_position){case u.before_newline:return L.space_before_token=!s,K(),a&&!o||E(),void(L.space_before_token=!0);case u.after_newline:return L.space_before_token=!0,!a||o?C(1).wanted_newline?x(!1,!0):E():L.space_before_token=!1,K(),void(L.space_before_token=!0);case u.preserve_newline:return s||E(),n=!(L.just_added_newline()||s),L.space_before_token=n,K(),void(L.space_before_token=!0)}}if(e){E(),n=!1;var l=C(1);i=l&&r(l.type,["TK_WORD","TK_RESERVED"])}else"..."===B.text?(E(),n="TK_START_BLOCK"===M,i=!1):(r(B.text,["--","++","!","~"])||t)&&(n=!1,i=!1,!B.wanted_newline||"--"!==B.text&&"++"!==B.text||x(!1,!0),";"===W.last_text&&w(W.mode)&&(n=!0),"TK_RESERVED"===M?n=!0:"TK_END_EXPR"===M?n=!("]"===W.last_text&&("--"===B.text||"++"===B.text)):"TK_OPERATOR"===M&&(n=r(B.text,["--","-","++","+"])&&r(W.last_text,["--","-","++","+"]),r(B.text,["+","-"])&&r(W.last_text,["--","++"])&&(i=!0)),(W.mode!==h.BlockStatement||W.inline_frame)&&W.mode!==h.Statement||"{"!==W.last_text&&";"!==W.last_text||x());L.space_before_token=L.space_before_token||n,K(),L.space_before_token=i}else K();else K()},TK_COMMA:function(){f(B,!0),K(),L.space_before_token=!0,W.declaration_statement?(w(W.parent.mode)&&(W.declaration_assignment=!1),W.declaration_assignment?(W.declaration_assignment=!1,x(!1,!0)):Q.comma_first&&E()):W.mode===h.ObjectLiteral||W.mode===h.Statement&&W.parent.mode===h.ObjectLiteral?(W.mode===h.Statement&&O(),W.inline_frame||x()):Q.comma_first&&E()},TK_BLOCK_COMMENT:function(e){if(L.raw)return L.add_raw_token(B),void(B.directives&&"end"===B.directives.preserve&&(L.raw=Q.test_output_raw));if(B.directives)return x(!1,e),K(),"start"===B.directives.preserve&&(L.raw=!0),void x(!1,!0);if(!l.newline.test(B.text)&&!B.wanted_newline)return L.space_before_token=!0,K(),void(L.space_before_token=!0);var t,n=T(B.text),i=!1,r=!1,_=B.whitespace_before,o=_.length;for(x(!1,e),n.length>1&&(i=g(n.slice(1),"*"),r=D(n.slice(1),_)),K(n[0]),t=1;t<n.length;t++)x(!1,!0),i?K(" "+a(n[t])):r&&n[t].length>o?K(n[t].substring(o)):L.add_token(n[t]);x(!1,e)},TK_COMMENT:function(e){B.wanted_newline?x(!1,e):L.trim(!0),L.space_before_token=!0,K(),x(!1,e)},TK_DOT:function(){y()||f(B,!0),"TK_RESERVED"===M&&A(W.last_text)?L.space_before_token=!0:E(")"===W.last_text&&Q.break_chained_methods),K()},TK_UNKNOWN:function(e){K(),"\n"===B.text[B.text.length-1]&&x(!1,e)},TK_EOF:function(){for(;W.mode===h.Statement;)O();f(B)}},t=s(t=t||{},"js"),Q={},"expand-strict"===t.brace_style?t.brace_style="expand":"collapse-preserve-inline"===t.brace_style?t.brace_style="collapse,preserve-inline":void 0!==t.braces_on_own_line?t.brace_style=t.braces_on_own_line?"expand":"collapse":t.brace_style||(t.brace_style="collapse");var G=t.brace_style.split(/[^a-zA-Z0-9_\-]+/);for(Q.brace_style=G[0],Q.brace_preserve_inline=!!G[1]&&G[1],Q.indent_size=t.indent_size?parseInt(t.indent_size,10):4,Q.indent_char=t.indent_char?t.indent_char:" ",Q.eol=t.eol?t.eol:"auto",Q.preserve_newlines=void 0===t.preserve_newlines||t.preserve_newlines,Q.unindent_chained_methods=void 0!==t.unindent_chained_methods&&t.unindent_chained_methods,Q.break_chained_methods=void 0!==t.break_chained_methods&&t.break_chained_methods,Q.max_preserve_newlines=void 0===t.max_preserve_newlines?0:parseInt(t.max_preserve_newlines,10),Q.space_in_paren=void 0!==t.space_in_paren&&t.space_in_paren,Q.space_in_empty_paren=void 0!==t.space_in_empty_paren&&t.space_in_empty_paren,Q.jslint_happy=void 0!==t.jslint_happy&&t.jslint_happy,Q.space_after_anon_function=void 0!==t.space_after_anon_function&&t.space_after_anon_function,Q.keep_array_indentation=void 0!==t.keep_array_indentation&&t.keep_array_indentation,Q.space_before_conditional=void 0===t.space_before_conditional||t.space_before_conditional,Q.unescape_strings=void 0!==t.unescape_strings&&t.unescape_strings,Q.wrap_line_length=void 0===t.wrap_line_length?0:parseInt(t.wrap_line_length,10),Q.e4x=void 0!==t.e4x&&t.e4x,Q.end_with_newline=void 0!==t.end_with_newline&&t.end_with_newline,Q.comma_first=void 0!==t.comma_first&&t.comma_first,Q.operator_position=o(t.operator_position),Q.test_output_raw=void 0!==t.test_output_raw&&t.test_output_raw,Q.jslint_happy&&(Q.space_after_anon_function=!0),t.indent_with_tabs&&(Q.indent_char="\t",Q.indent_size=1),"auto"===Q.eol&&(Q.eol="\n",e&&l.lineBreak.test(e||"")&&(Q.eol=e.match(l.lineBreak)[0])),Q.eol=Q.eol.replace(/\\r/,"\r").replace(/\\n/,"\n"),j="";Q.indent_size>0;)j+=Q.indent_char,Q.indent_size-=1;var Y=0;if(e&&e.length){for(;" "===e.charAt(Y)||"\t"===e.charAt(Y);)Y+=1;Z=e.substring(0,Y),e=e.substring(Y)}M="TK_START_BLOCK",I="",(L=new c(j,Z)).raw=Q.test_output_raw,z=[],v(h.BlockStatement),this.beautify=function(){for(P=new p(e,Q,j),$=P.tokenize(),V=0,B=C();B;)U[B.type](),I=W.last_text,M=B.type,W.last_text=B.text,V+=1,B=C();return L.get_code(Q.end_with_newline,Q.eol)};var q=["break","continue","return","throw","yield"]}},function(e,t){e.exports.InputScanner=function(e){var t=e,n=t.length,i=0;this.back=function(){i-=1},this.hasNext=function(){return i<n},this.next=function(){var e=null;return this.hasNext()&&(e=t.charAt(i),i+=1),e},this.peek=function(e){var r=null;return e=e||0,(e+=i)>=0&&e<n&&(r=t.charAt(e)),r},this.peekCharCode=function(e){var r=0;return e=e||0,(e+=i)>=0&&e<n&&(r=t.charCodeAt(e)),r},this.test=function(e,n){return n=n||0,e.lastIndex=i+n,e.test(t)},this.testChar=function(e,t){var n=this.peek(t);return null!==n&&e.test(n)},this.match=function(e){e.lastIndex=i;var n=e.exec(t);return n&&n.index===i?i+=n[0].length:n=null,n}}},function(e,t){e.exports.mergeOpts=function(e,t){var n,i={};for(n in e)n!==t&&(i[n]=e[n]);if(t in e)for(n in e[t])i[n]=e[t][n];return i}},function(e,t){function n(e){var t=0,n=-1,i=[],r=!0;this.set_indent=function(i){t=e.baseIndentLength+i*e.indent_length,n=i},this.get_character_count=function(){return t},this.is_empty=function(){return r},this.last=function(){return this._empty?null:i[i.length-1]},this.push=function(e){i.push(e),t+=e.length,r=!1},this.pop=function(){var e=null;return r||(e=i.pop(),t-=e.length,r=0===i.length),e},this.remove_indent=function(){n>0&&(n-=1,t-=e.indent_length)},this.trim=function(){for(;" "===this.last();)i.pop(),t-=1;r=0===i.length},this.toString=function(){var t="";return this._empty||(n>=0&&(t=e.indent_cache[n]),t+=i.join("")),t}}e.exports.Output=function(e,t){t=t||"",this.indent_cache=[t],this.baseIndentLength=t.length,this.indent_length=e.length,this.raw=!1;var i=[];this.baseIndentString=t,this.indent_string=e,this.previous_line=null,this.current_line=null,this.space_before_token=!1,this.add_outputline=function(){this.previous_line=this.current_line,this.current_line=new n(this),i.push(this.current_line)},this.add_outputline(),this.get_line_number=function(){return i.length},this.add_new_line=function(e){return!(1===this.get_line_number()&&this.just_added_newline()||!e&&this.just_added_newline()||(this.raw||this.add_outputline(),0))},this.get_code=function(e,t){var n=i.join("\n").replace(/[\r\n\t ]+$/,"");return e&&(n+="\n"),"\n"!==t&&(n=n.replace(/[\n]/g,t)),n},this.set_indent=function(e){if(i.length>1){for(;e>=this.indent_cache.length;)this.indent_cache.push(this.indent_cache[this.indent_cache.length-1]+this.indent_string);return this.current_line.set_indent(e),!0}return this.current_line.set_indent(0),!1},this.add_raw_token=function(e){for(var t=0;t<e.newlines;t++)this.add_outputline();this.current_line.push(e.whitespace_before),this.current_line.push(e.text),this.space_before_token=!1},this.add_token=function(e){this.add_space_before_token(),this.current_line.push(e)},this.add_space_before_token=function(){this.space_before_token&&!this.just_added_newline()&&this.current_line.push(" "),this.space_before_token=!1},this.remove_indent=function(e){for(var t=i.length;e<t;)i[e].remove_indent(),e++},this.trim=function(n){for(n=void 0!==n&&n,this.current_line.trim(e,t);n&&i.length>1&&this.current_line.is_empty();)i.pop(),this.current_line=i[i.length-1],this.current_line.trim();this.previous_line=i.length>1?i[i.length-2]:null},this.just_added_newline=function(){return this.current_line.is_empty()},this.just_added_blankline=function(){return!!this.just_added_newline()&&(1===i.length||i[i.length-2].is_empty())}}},function(e,t){e.exports.Token=function(e,t,n,i,r){this.type=e,this.text=t,this.comments_before=[],this.comments_after=[],this.newlines=n||0,this.wanted_newline=n>0,this.whitespace_before=i||"",this.parent=r||null,this.opened=null,this.directives=null}},function(e,t,n){var i=n(1).Beautifier;e.exports=function(e,t){return new i(e,t).beautify()}},function(e,t,n){function i(e){return e.replace(/^\s+|\s+$/g,"")}function r(e,t){for(var n=0;n<t.length;n+=1)if(t[n]===e)return!0;return!1}var _=n(2).InputScanner,a=n(5).Token,o=n(0);e.exports.Tokenizer=function(e,t){function n(e){if(!e.match(k))return null;var t={};w.lastIndex=0;for(var n=w.exec(e);n;)t[n[1]]=n[2],n=w.exec(e);return t}function s(){var e,_=[];T=0,E="";var s=K.next();if(null===s)return["","TK_EOF"];var k;for(k=R.length?R[R.length-1]:new a("TK_START_BLOCK","{");r(s,c);)if(o.newline.test(s)?"\n"===s&&"\r"===K.peek(-2)||(T+=1,_=[]):_.push(s),null===(s=K.next()))return["","TK_EOF"];if(_.length&&(E=_.join("")),p.test(s)||"."===s&&K.testChar(p)){var w=!0,y=!0,g=p;for("0"===s&&K.testChar(/[XxOoBb]/)?(w=!1,y=!1,g=K.testChar(/[Bb]/)?f:K.testChar(/[Oo]/)?u:d,s+=K.next()):"."===s?w=!1:(s="",K.back());K.testChar(g);)s+=K.next(),w&&"."===K.peek()&&(s+=K.next(),w=!1),y&&K.testChar(/[Ee]/)&&(s+=K.next(),K.testChar(/[+-]/)&&(s+=K.next()),y=!1,w=!1);return[s,"TK_WORD"]}if(o.isIdentifierStart(K.peekCharCode(-1))){if(K.hasNext())for(;o.isIdentifierChar(K.peekCharCode())&&(s+=K.next(),K.hasNext()););return"TK_DOT"===k.type||"TK_RESERVED"===k.type&&r(k.text,["set","get"])||!r(s,m)?[s,"TK_WORD"]:"in"===s||"of"===s?[s,"TK_OPERATOR"]:[s,"TK_RESERVED"]}if("("===s||"["===s)return[s,"TK_START_EXPR"];if(")"===s||"]"===s)return[s,"TK_END_EXPR"];if("{"===s)return[s,"TK_START_BLOCK"];if("}"===s)return[s,"TK_END_BLOCK"];if(";"===s)return[s,"TK_SEMICOLON"];if("/"===s){var D,A="";if("*"===K.peek()){K.next();var C=n(A="/*"+(D=K.match(b))[0]);return C&&"start"===C.ignore&&(A+=(D=K.match(O))[0]),A=A.replace(o.allLineBreaks,"\n"),[A,"TK_BLOCK_COMMENT",C]}if("/"===K.peek())return K.next(),D=K.match(v),A="//"+D[0],[A,"TK_COMMENT"]}var N=/<()([-a-zA-Z:0-9_.]+|{[\s\S]+?}|!\[CDATA\[[\s\S]*?\]\])(\s+{[\s\S]+?}|\s+[-a-zA-Z:0-9_.]+|\s+[-a-zA-Z:0-9_.]+\s*=\s*('[^']*'|"[^"]*"|{[\s\S]+?}))*\s*(\/?)\s*>/g;if("`"===s||"'"===s||'"'===s||("/"===s||t.e4x&&"<"===s&&K.test(N,-1))&&("TK_RESERVED"===k.type&&r(k.text,["return","case","throw","else","do","typeof","yield"])||"TK_END_EXPR"===k.type&&")"===k.text&&k.parent&&"TK_RESERVED"===k.parent.type&&r(k.parent.text,["if","while","for"])||r(k.type,["TK_COMMENT","TK_START_EXPR","TK_START_BLOCK","TK_END_BLOCK","TK_OPERATOR","TK_EQUALS","TK_EOF","TK_SEMICOLON","TK_COMMA"]))){var L=s,V=!1,P=!1;if(e=s,"/"===L)for(var B=!1;K.hasNext()&&(V||B||K.peek()!==L)&&!K.testChar(o.newline);)e+=K.peek(),V?V=!1:(V="\\"===K.peek(),"["===K.peek()?B=!0:"]"===K.peek()&&(B=!1)),K.next();else if(t.e4x&&"<"===L){var M=/[\s\S]*?<(\/?)([-a-zA-Z:0-9_.]+|{[\s\S]+?}|!\[CDATA\[[\s\S]*?\]\])(\s+{[\s\S]+?}|\s+[-a-zA-Z:0-9_.]+|\s+[-a-zA-Z:0-9_.]+\s*=\s*('[^']*'|"[^"]*"|{[\s\S]+?}))*\s*(\/?)\s*>/g;K.back();var I="",j=K.match(N);if(j){for(var W=j[2].replace(/^{\s+/,"{").replace(/\s+}$/,"}"),X=0===W.indexOf("{"),z=0;j;){var F=!!j[1],U=j[2];if(!(j[j.length-1]||"![CDATA["===U.slice(0,8))&&(U===W||X&&U.replace(/^{\s+/,"{").replace(/\s+}$/,"}"))&&(F?--z:++z),I+=j[0],z<=0)break;j=K.match(M)}return j||(I+=K.match(/[\s\S]*/g)[0]),I=I.replace(o.allLineBreaks,"\n"),[I,"TK_STRING"]}}else{var Q=function(t,n,i){for(var r;K.hasNext()&&(r=K.peek(),V||r!==t&&(n||!o.newline.test(r)));)(V||n)&&o.newline.test(r)?("\r"===r&&"\n"===K.peek(1)&&(K.next(),r=K.peek()),e+="\n"):e+=r,V?("x"!==r&&"u"!==r||(P=!0),V=!1):V="\\"===r,K.next(),i&&-1!==e.indexOf(i,e.length-i.length)&&("`"===t?Q("}",n,"`"):Q("`",n,"${"),K.hasNext()&&(e+=K.next()))};"`"===L?Q("`",!0,"${"):Q(L)}if(P&&t.unescape_strings&&(e=l(e)),K.peek()===L&&(e+=L,K.next(),"/"===L))for(;K.hasNext()&&o.isIdentifierStart(K.peekCharCode());)e+=K.next();return[e,"TK_STRING"]}if("#"===s){if(0===R.length&&"!"===K.peek()){for(e=s;K.hasNext()&&"\n"!==s;)s=K.next(),e+=s;return[i(e)+"\n","TK_UNKNOWN"]}var $="#";if(K.hasNext()&&K.testChar(p)){do{$+=s=K.next()}while(K.hasNext()&&"#"!==s&&"="!==s);return"#"===s||("["===K.peek()&&"]"===K.peek(1)?($+="[]",K.next(),K.next()):"{"===K.peek()&&"}"===K.peek(1)&&($+="{}",K.next(),K.next())),[$,"TK_WORD"]}}if("<"===s&&("?"===K.peek()||"%"===K.peek())){K.back();var Z=K.match(S);if(Z)return s=Z[0],s=s.replace(o.allLineBreaks,"\n"),[s,"TK_STRING"]}if("<"===s&&K.match(/\!--/g)){for(s="\x3c!--";K.hasNext()&&!K.testChar(o.newline);)s+=K.next();return x=!0,[s,"TK_COMMENT"]}if("-"===s&&x&&K.match(/->/g))return x=!1,["--\x3e","TK_COMMENT"];if("."===s)return"."===K.peek()&&"."===K.peek(1)?(s+=K.next()+K.next(),[s,"TK_OPERATOR"]):[s,"TK_DOT"];if(r(s,h)){for(;K.hasNext()&&r(s+K.peek(),h)&&(s+=K.next(),K.hasNext()););return","===s?[s,"TK_COMMA"]:"="===s?[s,"TK_EQUALS"]:[s,"TK_OPERATOR"]}return[s,"TK_UNKNOWN"]}function l(e){for(var t="",n=0,i=new _(e),r=null;i.hasNext();)if((r=i.match(/([\s]|[^\\]|\\\\)+/g))&&(t+=r[0]),"\\"===i.peek()){if(i.next(),"x"===i.peek())r=i.match(/x([0-9A-Fa-f]{2})/g);else{if("u"!==i.peek()){t+="\\",i.hasNext()&&(t+=i.next());continue}r=i.match(/u([0-9A-Fa-f]{4})/g)}if(!r)return e;if((n=parseInt(r[1],16))>126&&n<=255&&0===r[0].indexOf("x"))return e;if(n>=0&&n<32){t+="\\"+r[0];continue}t+=34===n||39===n||92===n?"\\"+String.fromCharCode(n):String.fromCharCode(n)}return t}var c="\n\r\t ".split(""),p=/[0-9]/,f=/[01]/,u=/[01234567]/,d=/[0123456789abcdefABCDEF]/;this.positionable_operators="!= !== % & && * ** + - / : < << <= == === > >= >> >>> ? ^ | ||".split(" ");var h=this.positionable_operators.concat("! %= &= *= **= ++ += , -- -= /= :: <<= = => >>= >>>= ^= |= ~ ...".split(" "));this.line_starters="continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export".split(",");var T,E,x,R,K,m=this.line_starters.concat(["do","in","of","else","get","set","new","catch","finally","typeof","yield","async","await","from","as"]),b=/([\s\S]*?)((?:\*\/)|$)/g,v=/([^\n\r\u2028\u2029]*)/g,k=/\/\* beautify( \w+[:]\w+)+ \*\//g,w=/ (\w+)[:](\w+)/g,O=/([\s\S]*?)((?:\/\*\sbeautify\signore:end\s\*\/)|$)/g,S=/((<\?php|<\?=)[\s\S]*?\?>)|(<%[\s\S]*?%>)/g;this.tokenize=function(){K=new _(e),x=!1,R=[];for(var t,n,i,r=null,o=[],l=[];!n||"TK_EOF"!==n.type;){for(i=s(),t=new a(i[1],i[0],T,E);"TK_COMMENT"===t.type||"TK_BLOCK_COMMENT"===t.type||"TK_UNKNOWN"===t.type;)"TK_BLOCK_COMMENT"===t.type&&(t.directives=i[2]),l.push(t),i=s(),t=new a(i[1],i[0],T,E);l.length&&(t.comments_before=l,l=[]),"TK_START_BLOCK"===t.type||"TK_START_EXPR"===t.type?(t.parent=n,o.push(r),r=t):("TK_END_BLOCK"===t.type||"TK_END_EXPR"===t.type)&&r&&("]"===t.text&&"["===r.text||")"===t.text&&"("===r.text||"}"===t.text&&"{"===r.text)&&(t.parent=r.parent,t.opened=r,r=o.pop()),R.push(t),n=t}return R}}}]);"function"==typeof define&&define.amd?define([],function(){return{js_beautify:e}}):"undefined"!=typeof exports?exports.js_beautify=e:"undefined"!=typeof window?window.js_beautify=e:"undefined"!=typeof global&&(global.js_beautify=e)}();

/**
 * https://github.com/csnover/TraceKit
 * @license MIT
 * @namespace TraceKit
 */
(function(window, undefined) {
if (!window) {
    return;
}

var TraceKit = {};
var _oldTraceKit = window.TraceKit;

// global reference to slice
var _slice = [].slice;
var UNKNOWN_FUNCTION = '?';

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types
var ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/;

/**
 * A better form of hasOwnProperty<br/>
 * Example: `_has(MainHostObject, property) === true/false`
 *
 * @param {Object} object to check property
 * @param {string} key to check
 * @return {Boolean} true if the object has the key and it is not inherited
 */
function _has(object, key) {
    return Object.prototype.hasOwnProperty.call(object, key);
}

/**
 * Returns true if the parameter is undefined<br/>
 * Example: `_isUndefined(val) === true/false`
 *
 * @param {*} what Value to check
 * @return {Boolean} true if undefined and false otherwise
 */
function _isUndefined(what) {
    return typeof what === 'undefined';
}

/**
 * Export TraceKit out to another variable<br/>
 * Example: `var TK = TraceKit.noConflict()`
 * @return {Object} The TraceKit object
 * @memberof TraceKit
 */
TraceKit.noConflict = function noConflict() {
    window.TraceKit = _oldTraceKit;
    return TraceKit;
};

/**
 * Wrap any function in a TraceKit reporter<br/>
 * Example: `func = TraceKit.wrap(func);`
 *
 * @param {Function} func Function to be wrapped
 * @return {Function} The wrapped func
 * @memberof TraceKit
 */
TraceKit.wrap = function traceKitWrapper(func) {
    function wrapped() {
        try {
            return func.apply(this, arguments);
        } catch (e) {
            TraceKit.report(e);
            throw e;
        }
    }
    return wrapped;
};

/**
 * Cross-browser processing of unhandled exceptions
 *
 * Syntax:
 * ```js
 *   TraceKit.report.subscribe(function(stackInfo) { ... })
 *   TraceKit.report.unsubscribe(function(stackInfo) { ... })
 *   TraceKit.report(exception)
 *   try { ...code... } catch(ex) { TraceKit.report(ex); }
 * ```
 *
 * Supports:
 *   - Firefox: full stack trace with line numbers, plus column number
 *     on top frame; column number is not guaranteed
 *   - Opera: full stack trace with line and column numbers
 *   - Chrome: full stack trace with line and column numbers
 *   - Safari: line and column number for the top frame only; some frames
 *     may be missing, and column number is not guaranteed
 *   - IE: line and column number for the top frame only; some frames
 *     may be missing, and column number is not guaranteed
 *
 * In theory, TraceKit should work on all of the following versions:
 *   - IE5.5+ (only 8.0 tested)
 *   - Firefox 0.9+ (only 3.5+ tested)
 *   - Opera 7+ (only 10.50 tested; versions 9 and earlier may require
 *     Exceptions Have Stacktrace to be enabled in opera:config)
 *   - Safari 3+ (only 4+ tested)
 *   - Chrome 1+ (only 5+ tested)
 *   - Konqueror 3.5+ (untested)
 *
 * Requires TraceKit.computeStackTrace.
 *
 * Tries to catch all unhandled exceptions and report them to the
 * subscribed handlers. Please note that TraceKit.report will rethrow the
 * exception. This is REQUIRED in order to get a useful stack trace in IE.
 * If the exception does not reach the top of the browser, you will only
 * get a stack trace from the point where TraceKit.report was called.
 *
 * Handlers receive a TraceKit.StackTrace object as described in the
 * TraceKit.computeStackTrace docs.
 *
 * @memberof TraceKit
 * @namespace
 */
TraceKit.report = (function reportModuleWrapper() {
    var handlers = [],
        lastException = null,
        lastExceptionStack = null;

    /**
     * Add a crash handler.
     * @param {Function} handler
     * @memberof TraceKit.report
     */
    function subscribe(handler) {
        installGlobalHandler();
        handlers.push(handler);
    }

    /**
     * Remove a crash handler.
     * @param {Function} handler
     * @memberof TraceKit.report
     */
    function unsubscribe(handler) {
        for (var i = handlers.length - 1; i >= 0; --i) {
            if (handlers[i] === handler) {
                handlers.splice(i, 1);
            }
        }

        if (handlers.length === 0) {
            window.onerror = _oldOnerrorHandler;
            _onErrorHandlerInstalled = false;
        }
    }

    /**
     * Dispatch stack information to all handlers.
     * @param {TraceKit.StackTrace} stack
     * @param {boolean} isWindowError Is this a top-level window error?
     * @param {Error=} error The error that's being handled (if available, null otherwise)
     * @memberof TraceKit.report
     * @throws An exception if an error occurs while calling an handler.
     */
    function notifyHandlers(stack, isWindowError, error) {
        var exception = null;
        if (isWindowError && !TraceKit.collectWindowErrors) {
          return;
        }
        for (var i in handlers) {
            if (_has(handlers, i)) {
                try {
                    handlers[i](stack, isWindowError, error);
                } catch (inner) {
                    exception = inner;
                }
            }
        }

        if (exception) {
            throw exception;
        }
    }

    var _oldOnerrorHandler, _onErrorHandlerInstalled;

    /**
     * Ensures all global unhandled exceptions are recorded.
     * Supported by Gecko and IE.
     * @param {string} message Error message.
     * @param {string} url URL of script that generated the exception.
     * @param {(number|string)} lineNo The line number at which the error occurred.
     * @param {(number|string)=} columnNo The column number at which the error occurred.
     * @param {Error=} errorObj The actual Error object.
     * @memberof TraceKit.report
     */
    function traceKitWindowOnError(message, url, lineNo, columnNo, errorObj) {
        var stack = null;

        if (lastExceptionStack) {
            TraceKit.computeStackTrace.augmentStackTraceWithInitialElement(lastExceptionStack, url, lineNo, message);
    	    processLastException();
        } else if (errorObj) {
            stack = TraceKit.computeStackTrace(errorObj);
            notifyHandlers(stack, true, errorObj);
        } else {
            var location = {
              'url': url,
              'line': lineNo,
              'column': columnNo
            };

            var name;
            var msg = message; // must be new var or will modify original `arguments`
            if ({}.toString.call(message) === '[object String]') {
                var groups = message.match(ERROR_TYPES_RE);
                if (groups) {
                    name = groups[1];
                    msg = groups[2];
                }
            }

            location.func = TraceKit.computeStackTrace.guessFunctionName(location.url, location.line);
            location.context = TraceKit.computeStackTrace.gatherContext(location.url, location.line, location.column);
            stack = {
                'name': name,
                'message': msg,
                'mode': 'onerror',
                'stack': [location]
            };

            notifyHandlers(stack, true, null);
        }

        if (_oldOnerrorHandler) {
            return _oldOnerrorHandler.apply(this, arguments);
        }

        return false;
    }

    /**
     * Install a global onerror handler
     * @memberof TraceKit.report
     */
    function installGlobalHandler() {
        if (_onErrorHandlerInstalled === true) {
            return;
        }

        _oldOnerrorHandler = window.onerror;
        window.onerror = traceKitWindowOnError;
        _onErrorHandlerInstalled = true;
    }

    /**
     * Process the most recent exception
     * @memberof TraceKit.report
     */
    function processLastException() {
        var _lastExceptionStack = lastExceptionStack,
            _lastException = lastException;
        lastExceptionStack = null;
        lastException = null;
        notifyHandlers(_lastExceptionStack, false, _lastException);
    }

    /**
     * Reports an unhandled Error to TraceKit.
     * @param {Error} ex
     * @memberof TraceKit.report
     * @throws An exception if an incomplete stack trace is detected (old IE browsers).
     */
    function report(ex) {
        if (lastExceptionStack) {
            if (lastException === ex) {
                return; // already caught by an inner catch block, ignore
            } else {
              processLastException();
            }
        }

        var stack = TraceKit.computeStackTrace(ex);
        lastExceptionStack = stack;
        lastException = ex;

        // If the stack trace is incomplete, wait for 2 seconds for
        // slow slow IE to see if onerror occurs or not before reporting
        // this exception; otherwise, we will end up with an incomplete
        // stack trace
        setTimeout(function () {
            if (lastException === ex) {
                processLastException();
            }
        }, (stack.incomplete ? 2000 : 0));

        throw ex; // re-throw to propagate to the top level (and cause window.onerror)
    }

    report.subscribe = subscribe;
    report.unsubscribe = unsubscribe;
    return report;
}());

/**
 * An object representing a single stack frame.
 * @typedef {Object} StackFrame
 * @property {string} url The JavaScript or HTML file URL.
 * @property {string} func The function name, or empty for anonymous functions (if guessing did not work).
 * @property {string[]?} args The arguments passed to the function, if known.
 * @property {number=} line The line number, if known.
 * @property {number=} column The column number, if known.
 * @property {string[]} context An array of source code lines; the middle element corresponds to the correct line#.
 * @memberof TraceKit
 */

/**
 * An object representing a JavaScript stack trace.
 * @typedef {Object} StackTrace
 * @property {string} name The name of the thrown exception.
 * @property {string} message The exception error message.
 * @property {TraceKit.StackFrame[]} stack An array of stack frames.
 * @property {string} mode 'stack', 'stacktrace', 'multiline', 'callers', 'onerror', or 'failed' -- method used to collect the stack trace.
 * @memberof TraceKit
 */

/**
 * TraceKit.computeStackTrace: cross-browser stack traces in JavaScript
 *
 * Syntax:
 *   ```js
 *   s = TraceKit.computeStackTrace.ofCaller([depth])
 *   s = TraceKit.computeStackTrace(exception) // consider using TraceKit.report instead (see below)
 *   ```
 *
 * Supports:
 *   - Firefox:  full stack trace with line numbers and unreliable column
 *               number on top frame
 *   - Opera 10: full stack trace with line and column numbers
 *   - Opera 9-: full stack trace with line numbers
 *   - Chrome:   full stack trace with line and column numbers
 *   - Safari:   line and column number for the topmost stacktrace element
 *               only
 *   - IE:       no line numbers whatsoever
 *
 * Tries to guess names of anonymous functions by looking for assignments
 * in the source code. In IE and Safari, we have to guess source file names
 * by searching for function bodies inside all page scripts. This will not
 * work for scripts that are loaded cross-domain.
 * Here be dragons: some function names may be guessed incorrectly, and
 * duplicate functions may be mismatched.
 *
 * TraceKit.computeStackTrace should only be used for tracing purposes.
 * Logging of unhandled exceptions should be done with TraceKit.report,
 * which builds on top of TraceKit.computeStackTrace and provides better
 * IE support by utilizing the window.onerror event to retrieve information
 * about the top of the stack.
 *
 * Note: In IE and Safari, no stack trace is recorded on the Error object,
 * so computeStackTrace instead walks its *own* chain of callers.
 * This means that:
 *  * in Safari, some methods may be missing from the stack trace;
 *  * in IE, the topmost function in the stack trace will always be the
 *    caller of computeStackTrace.
 *
 * This is okay for tracing (because you are likely to be calling
 * computeStackTrace from the function you want to be the topmost element
 * of the stack trace anyway), but not okay for logging unhandled
 * exceptions (because your catch block will likely be far away from the
 * inner function that actually caused the exception).
 *
 * Tracing example:
 *  ```js
 *     function trace(message) {
 *         var stackInfo = TraceKit.computeStackTrace.ofCaller();
 *         var data = message + "\n";
 *         for(var i in stackInfo.stack) {
 *             var item = stackInfo.stack[i];
 *             data += (item.func || '[anonymous]') + "() in " + item.url + ":" + (item.line || '0') + "\n";
 *         }
 *         if (window.console)
 *             console.info(data);
 *         else
 *             alert(data);
 *     }
 * ```
 * @memberof TraceKit
 * @namespace
 */
TraceKit.computeStackTrace = (function computeStackTraceWrapper() {
    var debug = false,
        sourceCache = {};

    /**
     * Attempts to retrieve source code via XMLHttpRequest, which is used
     * to look up anonymous function names.
     * @param {string} url URL of source code.
     * @return {string} Source contents.
     * @memberof TraceKit.computeStackTrace
     */
    function loadSource(url) {
        if (!TraceKit.remoteFetching) { //Only attempt request if remoteFetching is on.
            return '';
        }
        try {
            var getXHR = function() {
                try {
                    return new window.XMLHttpRequest();
                } catch (e) {
                    // explicitly bubble up the exception if not found
                    return new window.ActiveXObject('Microsoft.XMLHTTP');
                }
            };

            var request = getXHR();
            request.open('GET', url, false);
            request.send('');
            return request.responseText;
        } catch (e) {
            return '';
        }
    }

    /**
     * Retrieves source code from the source code cache.
     * @param {string} url URL of source code.
     * @return {Array.<string>} Source contents.
     * @memberof TraceKit.computeStackTrace
     */
    function getSource(url) {
        if (typeof url !== 'string') {
            return [];
        }

        if (!_has(sourceCache, url)) {
            // URL needs to be able to fetched within the acceptable domain.  Otherwise,
            // cross-domain errors will be triggered.
            /*
                Regex matches:
                0 - Full Url
                1 - Protocol
                2 - Domain
                3 - Port (Useful for internal applications)
                4 - Path
            */
            var source = '';
            var domain = '';
            try { domain = window.document.domain; } catch (e) { }
            var match = /(.*)\:\/\/([^:\/]+)([:\d]*)\/{0,1}([\s\S]*)/.exec(url);
            if (match && match[2] === domain) {
                source = loadSource(url);
            }
            sourceCache[url] = source ? source.split('\n') : [];
        }

        return sourceCache[url];
    }

    /**
     * Tries to use an externally loaded copy of source code to determine
     * the name of a function by looking at the name of the variable it was
     * assigned to, if any.
     * @param {string} url URL of source code.
     * @param {(string|number)} lineNo Line number in source code.
     * @return {string} The function name, if discoverable.
     * @memberof TraceKit.computeStackTrace
     */
    function guessFunctionName(url, lineNo) {
        var reFunctionArgNames = /function ([^(]*)\(([^)]*)\)/,
            reGuessFunction = /['"]?([0-9A-Za-z$_]+)['"]?\s*[:=]\s*(function|eval|new Function)/,
            line = '',
            maxLines = 10,
            source = getSource(url),
            m;

        if (!source.length) {
            return UNKNOWN_FUNCTION;
        }

        // Walk backwards from the first line in the function until we find the line which
        // matches the pattern above, which is the function definition
        for (var i = 0; i < maxLines; ++i) {
            line = source[lineNo - i] + line;

            if (!_isUndefined(line)) {
                if ((m = reGuessFunction.exec(line))) {
                    return m[1];
                } else if ((m = reFunctionArgNames.exec(line))) {
                    return m[1];
                }
            }
        }

        return UNKNOWN_FUNCTION;
    }

    function getCleanedSource(source) {
        var b = js_beautify.beautify(source);
        return b;
    }

    function getMinifiedContext(source, line, column) {
        var sourceLine = source[line-1];
        const buffer = sourceLine.substr(Math.max(0, column-1000), Math.min(sourceLine.length, column + 1000));
        var b = js_beautify.beautify(b);
        //const semicolons = buffer.split(';');

        console.log('Minified semicolon blob', b);
        return b;
    }

    /**
     * Retrieves the surrounding lines from where an exception occurred.
     * @param {string} url URL of source code.
     * @param {(string|number)} line Line number in source code to center around for context.
     * @return {?Array.<string>} Lines of source code.
     * @memberof TraceKit.computeStackTrace
     */
    function gatherContext(url, line, column) {
        var source = getSource(url);

        if (!source.length) {
            return null;
        }

        var numLines = source.length + 1;
        var size = source.reduce(function(sum, line) {
            return sum + line.length;
        }, 0);

        var avgLengthPerLine = size / numLines;

        var isMinified = avgLengthPerLine > 1000;

        // Are the lines of this file on average longer than 1000 characters?
        // If so, that's probably a minified mess
        if (isMinified) {
            console.log('Big ass minified file', url, avgLengthPerLine);
            console.log('Gathering context at', line, column);
            getMinifiedContext(source, line, column);
        }

        var context = [],
            // linesBefore & linesAfter are inclusive with the offending line.
            // if linesOfContext is even, there will be one extra line
            //   *before* the offending line.
            linesBefore = Math.floor(TraceKit.linesOfContext / 2),
            // Add one extra line if linesOfContext is odd
            linesAfter = linesBefore + (TraceKit.linesOfContext % 2),
            start = Math.max(0, line - linesBefore - 1),
            end = Math.min(source.length, line + linesAfter - 1);

        line -= 1; // convert to 0-based index

        for (var i = start; i < end; ++i) {
            if (!_isUndefined(source[i])) {
                context.push(source[i]);
            }
        }

        return context.length > 0 ? context : null;
    }

    /**
     * Escapes special characters, except for whitespace, in a string to be
     * used inside a regular expression as a string literal.
     * @param {string} text The string.
     * @return {string} The escaped string literal.
     * @memberof TraceKit.computeStackTrace
     */
    function escapeRegExp(text) {
        return text.replace(/[\-\[\]{}()*+?.,\\\^$|#]/g, '\\$&');
    }

    /**
     * Escapes special characters in a string to be used inside a regular
     * expression as a string literal. Also ensures that HTML entities will
     * be matched the same as their literal friends.
     * @param {string} body The string.
     * @return {string} The escaped string.
     * @memberof TraceKit.computeStackTrace
     */
    function escapeCodeAsRegExpForMatchingInsideHTML(body) {
        return escapeRegExp(body).replace('<', '(?:<|&lt;)').replace('>', '(?:>|&gt;)').replace('&', '(?:&|&amp;)').replace('"', '(?:"|&quot;)').replace(/\s+/g, '\\s+');
    }

    /**
     * Determines where a code fragment occurs in the source code.
     * @param {RegExp} re The function definition.
     * @param {Array.<string>} urls A list of URLs to search.
     * @return {?Object.<string, (string|number)>} An object containing
     * the url, line, and column number of the defined function.
     * @memberof TraceKit.computeStackTrace
     */
    function findSourceInUrls(re, urls) {
        var source, m;
        for (var i = 0, j = urls.length; i < j; ++i) {
            if ((source = getSource(urls[i])).length) {
                source = source.join('\n');
                if ((m = re.exec(source))) {

                    return {
                        'url': urls[i],
                        'line': source.substring(0, m.index).split('\n').length,
                        'column': m.index - source.lastIndexOf('\n', m.index) - 1
                    };
                }
            }
        }

        return null;
    }

    /**
     * Determines at which column a code fragment occurs on a line of the
     * source code.
     * @param {string} fragment The code fragment.
     * @param {string} url The URL to search.
     * @param {(string|number)} line The line number to examine.
     * @return {?number} The column number.
     * @memberof TraceKit.computeStackTrace
     */
    function findSourceInLine(fragment, url, line) {
        var source = getSource(url),
            re = new RegExp('\\b' + escapeRegExp(fragment) + '\\b'),
            m;

        line -= 1;

        if (source && source.length > line && (m = re.exec(source[line]))) {
            return m.index;
        }

        return null;
    }

    /**
     * Determines where a function was defined within the source code.
     * @param {(Function|string)} func A function reference or serialized
     * function definition.
     * @return {?Object.<string, (string|number)>} An object containing
     * the url, line, and column number of the defined function.
     * @memberof TraceKit.computeStackTrace
     */
    function findSourceByFunctionBody(func) {
        if (_isUndefined(window && window.document)) {
            return;
        }

        var urls = [window.location.href],
            scripts = window.document.getElementsByTagName('script'),
            body,
            code = '' + func,
            codeRE = /^function(?:\s+([\w$]+))?\s*\(([\w\s,]*)\)\s*\{\s*(\S[\s\S]*\S)\s*\}\s*$/,
            eventRE = /^function on([\w$]+)\s*\(event\)\s*\{\s*(\S[\s\S]*\S)\s*\}\s*$/,
            re,
            parts,
            result;

        for (var i = 0; i < scripts.length; ++i) {
            var script = scripts[i];
            if (script.src) {
                urls.push(script.src);
            }
        }

        if (!(parts = codeRE.exec(code))) {
            re = new RegExp(escapeRegExp(code).replace(/\s+/g, '\\s+'));
        }

        // not sure if this is really necessary, but I don’t have a test
        // corpus large enough to confirm that and it was in the original.
        else {
            var name = parts[1] ? '\\s+' + parts[1] : '',
                args = parts[2].split(',').join('\\s*,\\s*');

            body = escapeRegExp(parts[3]).replace(/;$/, ';?'); // semicolon is inserted if the function ends with a comment.replace(/\s+/g, '\\s+');
            re = new RegExp('function' + name + '\\s*\\(\\s*' + args + '\\s*\\)\\s*{\\s*' + body + '\\s*}');
        }

        // look for a normal function definition
        if ((result = findSourceInUrls(re, urls))) {
            return result;
        }

        // look for an old-school event handler function
        if ((parts = eventRE.exec(code))) {
            var event = parts[1];
            body = escapeCodeAsRegExpForMatchingInsideHTML(parts[2]);

            // look for a function defined in HTML as an onXXX handler
            re = new RegExp('on' + event + '=[\\\'"]\\s*' + body + '\\s*[\\\'"]', 'i');

            if ((result = findSourceInUrls(re, urls[0]))) {
                return result;
            }

            // look for ???
            re = new RegExp(body);

            if ((result = findSourceInUrls(re, urls))) {
                return result;
            }
        }

        return null;
    }

    // Contents of Exception in various browsers.
    //
    // SAFARI:
    // ex.message = Can't find variable: qq
    // ex.line = 59
    // ex.sourceId = 580238192
    // ex.sourceURL = http://...
    // ex.expressionBeginOffset = 96
    // ex.expressionCaretOffset = 98
    // ex.expressionEndOffset = 98
    // ex.name = ReferenceError
    //
    // FIREFOX:
    // ex.message = qq is not defined
    // ex.fileName = http://...
    // ex.lineNumber = 59
    // ex.columnNumber = 69
    // ex.stack = ...stack trace... (see the example below)
    // ex.name = ReferenceError
    //
    // CHROME:
    // ex.message = qq is not defined
    // ex.name = ReferenceError
    // ex.type = not_defined
    // ex.arguments = ['aa']
    // ex.stack = ...stack trace...
    //
    // INTERNET EXPLORER:
    // ex.message = ...
    // ex.name = ReferenceError
    //
    // OPERA:
    // ex.message = ...message... (see the example below)
    // ex.name = ReferenceError
    // ex.opera#sourceloc = 11  (pretty much useless, duplicates the info in ex.message)
    // ex.stacktrace = n/a; see 'opera:config#UserPrefs|Exceptions Have Stacktrace'

    /**
     * Computes stack trace information from the stack property.
     * Chrome and Gecko use this property.
     * @param {Error} ex
     * @return {?TraceKit.StackTrace} Stack trace information.
     * @memberof TraceKit.computeStackTrace
     */
    function computeStackTraceFromStackProp(ex) {
        if (!ex.stack) {
            return null;
        }

        var chrome = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,
            gecko = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i,
            winjs = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i,

            // Used to additionally parse URL/line/column from eval frames
            isEval,
            geckoEval = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i,
            chromeEval = /\((\S*)(?::(\d+))(?::(\d+))\)/,

            lines = ex.stack.split('\n'),
            stack = [],
            submatch,
            parts,
            element,
            reference = /^(.*) is undefined$/.exec(ex.message);

        for (var i = 0, j = lines.length; i < j; ++i) {
            if ((parts = chrome.exec(lines[i]))) {
                var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line
                isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line
                if (isEval && (submatch = chromeEval.exec(parts[2]))) {
                    // throw out eval line/column and use top-most line/column number
                    parts[2] = submatch[1]; // url
                    parts[3] = submatch[2]; // line
                    parts[4] = submatch[3]; // column
                }
                element = {
                    'url': !isNative ? parts[2] : null,
                    'func': parts[1] || UNKNOWN_FUNCTION,
                    'args': isNative ? [parts[2]] : [],
                    'line': parts[3] ? +parts[3] : null,
                    'column': parts[4] ? +parts[4] : null
                };
            } else if ( parts = winjs.exec(lines[i]) ) {
                element = {
                    'url': parts[2],
                    'func': parts[1] || UNKNOWN_FUNCTION,
                    'args': [],
                    'line': +parts[3],
                    'column': parts[4] ? +parts[4] : null
                };
            } else if ((parts = gecko.exec(lines[i]))) {
                isEval = parts[3] && parts[3].indexOf(' > eval') > -1;
                if (isEval && (submatch = geckoEval.exec(parts[3]))) {
                    // throw out eval line/column and use top-most line number
                    parts[3] = submatch[1];
                    parts[4] = submatch[2];
                    parts[5] = null; // no column when eval
                } else if (i === 0 && !parts[5] && !_isUndefined(ex.columnNumber)) {
                    // FireFox uses this awesome columnNumber property for its top frame
                    // Also note, Firefox's column number is 0-based and everything else expects 1-based,
                    // so adding 1
                    // NOTE: this hack doesn't work if top-most frame is eval
                    stack[0].column = ex.columnNumber + 1;
                }
                element = {
                    'url': parts[3],
                    'func': parts[1] || UNKNOWN_FUNCTION,
                    'args': parts[2] ? parts[2].split(',') : [],
                    'line': parts[4] ? +parts[4] : null,
                    'column': parts[5] ? +parts[5] : null
                };
            } else {
                continue;
            }

            if (!element.func && element.line) {
                element.func = guessFunctionName(element.url, element.line);
            }

            element.context = element.line ? gatherContext(element.url, element.line, element.column) : null;
            stack.push(element);
        }

        if (!stack.length) {
            return null;
        }

        if (stack[0] && stack[0].line && !stack[0].column && reference) {
            stack[0].column = findSourceInLine(reference[1], stack[0].url, stack[0].line);
        }

        return {
            'mode': 'stack',
            'name': ex.name,
            'message': ex.message,
            'stack': stack
        };
    }

    /**
     * Computes stack trace information from the stacktrace property.
     * Opera 10+ uses this property.
     * @param {Error} ex
     * @return {?TraceKit.StackTrace} Stack trace information.
     * @memberof TraceKit.computeStackTrace
     */
    function computeStackTraceFromStacktraceProp(ex) {
        // Access and store the stacktrace property before doing ANYTHING
        // else to it because Opera is not very good at providing it
        // reliably in other circumstances.
        var stacktrace = ex.stacktrace;
        if (!stacktrace) {
            return;
        }

        var opera10Regex = / line (\d+).*script (?:in )?(\S+)(?:: in function (\S+))?$/i,
            opera11Regex = / line (\d+), column (\d+)\s*(?:in (?:<anonymous function: ([^>]+)>|([^\)]+))\((.*)\))? in (.*):\s*$/i,
            lines = stacktrace.split('\n'),
            stack = [],
            parts;

        for (var line = 0; line < lines.length; line += 2) {
            var element = null;
            if ((parts = opera10Regex.exec(lines[line]))) {
                element = {
                    'url': parts[2],
                    'line': +parts[1],
                    'column': null,
                    'func': parts[3],
                    'args':[]
                };
            } else if ((parts = opera11Regex.exec(lines[line]))) {
                element = {
                    'url': parts[6],
                    'line': +parts[1],
                    'column': +parts[2],
                    'func': parts[3] || parts[4],
                    'args': parts[5] ? parts[5].split(',') : []
                };
            }

            if (element) {
                if (!element.func && element.line) {
                    element.func = guessFunctionName(element.url, element.line, element.column);
                }
                if (element.line) {
                    try {
                        element.context = gatherContext(element.url, element.line, element.column);
                    } catch (exc) {}
                }

                if (!element.context) {
                    element.context = [lines[line + 1]];
                }

                stack.push(element);
            }
        }

        if (!stack.length) {
            return null;
        }

        return {
            'mode': 'stacktrace',
            'name': ex.name,
            'message': ex.message,
            'stack': stack
        };
    }

    /**
     * NOT TESTED.
     * Computes stack trace information from an error message that includes
     * the stack trace.
     * Opera 9 and earlier use this method if the option to show stack
     * traces is turned on in opera:config.
     * @param {Error} ex
     * @return {?TraceKit.StackTrace} Stack information.
     * @memberof TraceKit.computeStackTrace
     */
    function computeStackTraceFromOperaMultiLineMessage(ex) {
        // TODO: Clean this function up
        // Opera includes a stack trace into the exception message. An example is:
        //
        // Statement on line 3: Undefined variable: undefinedFunc
        // Backtrace:
        //   Line 3 of linked script file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.js: In function zzz
        //         undefinedFunc(a);
        //   Line 7 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html: In function yyy
        //           zzz(x, y, z);
        //   Line 3 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html: In function xxx
        //           yyy(a, a, a);
        //   Line 1 of function script
        //     try { xxx('hi'); return false; } catch(ex) { TraceKit.report(ex); }
        //   ...

        var lines = ex.message.split('\n');
        if (lines.length < 4) {
            return null;
        }

        var lineRE1 = /^\s*Line (\d+) of linked script ((?:file|https?|blob)\S+)(?:: in function (\S+))?\s*$/i,
            lineRE2 = /^\s*Line (\d+) of inline#(\d+) script in ((?:file|https?|blob)\S+)(?:: in function (\S+))?\s*$/i,
            lineRE3 = /^\s*Line (\d+) of function script\s*$/i,
            stack = [],
            scripts = (window && window.document && window.document.getElementsByTagName('script')),
            inlineScriptBlocks = [],
            parts;

        for (var s in scripts) {
            if (_has(scripts, s) && !scripts[s].src) {
                inlineScriptBlocks.push(scripts[s]);
            }
        }

        for (var line = 2; line < lines.length; line += 2) {
            var item = null;
            if ((parts = lineRE1.exec(lines[line]))) {
                item = {
                    'url': parts[2],
                    'func': parts[3],
                    'args': [],
                    'line': +parts[1],
                    'column': null
                };
            } else if ((parts = lineRE2.exec(lines[line]))) {
                item = {
                    'url': parts[3],
                    'func': parts[4],
                    'args': [],
                    'line': +parts[1],
                    'column': null // TODO: Check to see if inline#1 (+parts[2]) points to the script number or column number.
                };
                var relativeLine = (+parts[1]); // relative to the start of the <SCRIPT> block
                var script = inlineScriptBlocks[parts[2] - 1];
                if (script) {
                    var source = getSource(item.url);
                    if (source) {
                        source = source.join('\n');
                        var pos = source.indexOf(script.innerText);
                        if (pos >= 0) {
                            item.line = relativeLine + source.substring(0, pos).split('\n').length;
                        }
                    }
                }
            } else if ((parts = lineRE3.exec(lines[line]))) {
                var url = window.location.href.replace(/#.*$/, '');
                var re = new RegExp(escapeCodeAsRegExpForMatchingInsideHTML(lines[line + 1]));
                var src = findSourceInUrls(re, [url]);
                item = {
                    'url': url,
                    'func': '',
                    'args': [],
                    'line': src ? src.line : parts[1],
                    'column': null
                };
            }

            if (item) {
                if (!item.func) {
                    item.func = guessFunctionName(item.url, item.line);
                }
                var context = gatherContext(item.url, item.line, item.column);
                var midline = (context ? context[Math.floor(context.length / 2)] : null);
                if (context && midline.replace(/^\s*/, '') === lines[line + 1].replace(/^\s*/, '')) {
                    item.context = context;
                } else {
                    // if (context) alert("Context mismatch. Correct midline:\n" + lines[i+1] + "\n\nMidline:\n" + midline + "\n\nContext:\n" + context.join("\n") + "\n\nURL:\n" + item.url);
                    item.context = [lines[line + 1]];
                }
                stack.push(item);
            }
        }
        if (!stack.length) {
            return null; // could not parse multiline exception message as Opera stack trace
        }

        return {
            'mode': 'multiline',
            'name': ex.name,
            'message': lines[0],
            'stack': stack
        };
    }

    /**
     * Adds information about the first frame to incomplete stack traces.
     * Safari and IE require this to get complete data on the first frame.
     * @param {TraceKit.StackTrace} stackInfo Stack trace information from
     * one of the compute* methods.
     * @param {string} url The URL of the script that caused an error.
     * @param {(number|string)} lineNo The line number of the script that
     * caused an error.
     * @param {string=} message The error generated by the browser, which
     * hopefully contains the name of the object that caused the error.
     * @return {boolean} Whether or not the stack information was
     * augmented.
     * @memberof TraceKit.computeStackTrace
     */
    function augmentStackTraceWithInitialElement(stackInfo, url, lineNo, message) {
        var initial = {
            'url': url,
            'line': lineNo
        };

        if (initial.url && initial.line) {
            stackInfo.incomplete = false;

            if (!initial.func) {
                initial.func = guessFunctionName(initial.url, initial.line);
            }

            if (!initial.context) {
                initial.context = gatherContext(initial.url, initial.line, initial.column);
            }

            var reference = / '([^']+)' /.exec(message);
            if (reference) {
                initial.column = findSourceInLine(reference[1], initial.url, initial.line);
            }

            if (stackInfo.stack.length > 0) {
                if (stackInfo.stack[0].url === initial.url) {
                    if (stackInfo.stack[0].line === initial.line) {
                        return false; // already in stack trace
                    } else if (!stackInfo.stack[0].line && stackInfo.stack[0].func === initial.func) {
                        stackInfo.stack[0].line = initial.line;
                        stackInfo.stack[0].context = initial.context;
                        return false;
                    }
                }
            }

            stackInfo.stack.unshift(initial);
            stackInfo.partial = true;
            return true;
        } else {
            stackInfo.incomplete = true;
        }

        return false;
    }

    /**
     * Computes stack trace information by walking the arguments.caller
     * chain at the time the exception occurred. This will cause earlier
     * frames to be missed but is the only way to get any stack trace in
     * Safari and IE. The top frame is restored by
     * {@link augmentStackTraceWithInitialElement}.
     * @param {Error} ex
     * @return {TraceKit.StackTrace=} Stack trace information.
     * @memberof TraceKit.computeStackTrace
     */
    function computeStackTraceByWalkingCallerChain(ex, depth) {
        var functionName = /function\s+([_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*)?\s*\(/i,
            stack = [],
            funcs = {},
            recursion = false,
            parts,
            item,
            source;

        for (var curr = computeStackTraceByWalkingCallerChain.caller; curr && !recursion; curr = curr.caller) {
            if (curr === computeStackTrace || curr === TraceKit.report) {
                continue;
            }

            item = {
                'url': null,
                'func': UNKNOWN_FUNCTION,
                'args': [],
                'line': null,
                'column': null
            };

            if (curr.name) {
                item.func = curr.name;
            } else if ((parts = functionName.exec(curr.toString()))) {
                item.func = parts[1];
            }

            if (typeof item.func === 'undefined') {
              try {
                item.func = parts.input.substring(0, parts.input.indexOf('{'));
              } catch (e) { }
            }

            if ((source = findSourceByFunctionBody(curr))) {
                item.url = source.url;
                item.line = source.line;

                if (item.func === UNKNOWN_FUNCTION) {
                    item.func = guessFunctionName(item.url, item.line);
                }

                var reference = / '([^']+)' /.exec(ex.message || ex.description);
                if (reference) {
                    item.column = findSourceInLine(reference[1], source.url, source.line);
                }
            }

            if (funcs['' + curr]) {
                recursion = true;
            }else{
                funcs['' + curr] = true;
            }

            stack.push(item);
        }

        if (depth) {
            stack.splice(0, depth);
        }

        var result = {
            'mode': 'callers',
            'name': ex.name,
            'message': ex.message,
            'stack': stack
        };
        augmentStackTraceWithInitialElement(result, ex.sourceURL || ex.fileName, ex.line || ex.lineNumber, ex.message || ex.description);
        return result;
    }

    /**
     * Computes a stack trace for an exception.
     * @param {Error} ex
     * @param {(string|number)=} depth
     * @memberof TraceKit.computeStackTrace
     */
    function computeStackTrace(ex, depth) {
        var stack = null;
        depth = (depth == null ? 0 : +depth);

        try {
            // This must be tried first because Opera 10 *destroys*
            // its stacktrace property if you try to access the stack
            // property first!!
            stack = computeStackTraceFromStacktraceProp(ex);
            if (stack) {
                return stack;
            }
        } catch (e) {
            if (debug) {
                throw e;
            }
        }

        try {
            stack = computeStackTraceFromStackProp(ex);
            if (stack) {
                return stack;
            }
        } catch (e) {
            if (debug) {
                throw e;
            }
        }

        try {
            stack = computeStackTraceFromOperaMultiLineMessage(ex);
            if (stack) {
                return stack;
            }
        } catch (e) {
            if (debug) {
                throw e;
            }
        }

        try {
            stack = computeStackTraceByWalkingCallerChain(ex, depth + 1);
            if (stack) {
                return stack;
            }
        } catch (e) {
            if (debug) {
                throw e;
            }
        }

        return {
            'name': ex.name,
            'message': ex.message,
            'mode': 'failed'
        };
    }

    /**
     * Logs a stacktrace starting from the previous call and working down.
     * @param {(number|string)=} depth How many frames deep to trace.
     * @return {TraceKit.StackTrace} Stack trace information.
     * @memberof TraceKit.computeStackTrace
     */
    function computeStackTraceOfCaller(depth) {
        depth = (depth == null ? 0 : +depth) + 1; // "+ 1" because "ofCaller" should drop one frame
        try {
            throw new Error();
        } catch (ex) {
            return computeStackTrace(ex, depth + 1);
        }
    }

    computeStackTrace.augmentStackTraceWithInitialElement = augmentStackTraceWithInitialElement;
    computeStackTrace.computeStackTraceFromStackProp = computeStackTraceFromStackProp;
    computeStackTrace.guessFunctionName = guessFunctionName;
    computeStackTrace.gatherContext = gatherContext;
    computeStackTrace.ofCaller = computeStackTraceOfCaller;
    computeStackTrace.getSource = getSource;

    return computeStackTrace;
}());

/**
 * Extends support for global error handling for asynchronous browser
 * functions. Adopted from Closure Library's errorhandler.js
 * @memberof TraceKit
 */
TraceKit.extendToAsynchronousCallbacks = function () {
    var _helper = function _helper(fnName) {
        var originalFn = window[fnName];
        window[fnName] = function traceKitAsyncExtension() {
            // Make a copy of the arguments
            var args = _slice.call(arguments);
            var originalCallback = args[0];
            if (typeof (originalCallback) === 'function') {
                args[0] = TraceKit.wrap(originalCallback);
            }
            // IE < 9 doesn't support .call/.apply on setInterval/setTimeout, but it
            // also only supports 2 argument and doesn't care what "this" is, so we
            // can just call the original function directly.
            if (originalFn.apply) {
                return originalFn.apply(this, args);
            } else {
                return originalFn(args[0], args[1]);
            }
        };
    };

    _helper('setTimeout');
    _helper('setInterval');
};

//Default options:
if (!TraceKit.remoteFetching) {
    TraceKit.remoteFetching = true;
}
if (!TraceKit.collectWindowErrors) {
    TraceKit.collectWindowErrors = true;
}
if (!TraceKit.linesOfContext || TraceKit.linesOfContext < 1) {
    // 5 lines before, the offending line, 5 lines after
    TraceKit.linesOfContext = 11;
}

// UMD export
if (typeof define === 'function' && define.amd) {
    define('TraceKit', [], TraceKit);
} else if (typeof module !== 'undefined' && module.exports && window.module !== module) {
    module.exports = TraceKit;
} else {
    window.TraceKit = TraceKit;
}

}(typeof window !== 'undefined' ? window : global));
